#include <SDL3/SDL.h>
#include <SDL3_ttf/SDL_ttf.h>
#include <iostream>
#include <vector>
#include <string>
#include <unordered_map>
#include <ctime>
#include <cstdlib>

using std::cin;
using std::cout;
using std::endl;
using std::vector;
using std::unordered_set;
using std::string;

struct temka { //Ğ½Ğ°ÑˆĞ¸ Ñ‚ĞµĞ¼Ñ‹
    std::string player, monster, wall, point, empty = "  ";
}

int WIDTH, HEIGHT; //Ğ½Ñƒ Ñ‚ÑƒÑ‚ Ğ¿Ğ¾Ğ½ÑÑ‚Ğ½Ğ¾
int attempts = 0;
bool gameover;

struct Entity { //ĞºĞ¾Ğ¾Ñ€Ğ´Ğ¸Ğ½Ğ°Ñ‚Ñ‹ ĞºĞ°ĞºĞ¾Ğ¹ Ñ‚Ğ¾ ÑÑƒÑ‰Ğ½Ğ¾ÑÑ‚Ğ¸
   int x, y;
}

Entity player;
std::vector<Entity> monsters



temka sea    = {"ğŸ ", "ğŸ¦ˆ", "ğŸª¸", "âšª", "â­"};   // ĞœĞ¾Ñ€ÑĞºĞ°Ñ
temka forest = {"ğŸ°", "ğŸº", "ğŸŒ²", "ğŸ„", "ğŸ¥•"};   // Ğ›ĞµÑĞ½Ğ°Ñ
temka city   = {"ğŸš—", "ğŸ‘®", "ğŸš§", "ğŸ›", "ğŸ’"};   // Ğ“Ğ¾Ñ€Ğ¾Ğ´ÑĞºĞ°Ñ
temka space  = {"ğŸš€", "ğŸ‘¾", "ğŸŒ‘", "âœ¨", "ğŸŒŸ"};   // ĞšĞ¾ÑĞ¼Ğ¸Ñ‡ĞµÑĞºĞ°Ñ

std::vector<temka> thems = {sea, forest};
Theme now_t = sea;
std::vector<vector<string>> now;


std::unordered_map<string, vector<vector<vector<string>>>> LevelsByThems = {
    {"sea", {
        {{"ğŸª¸","ğŸª¸","ğŸª¸","ğŸª¸","ğŸª¸","ğŸª¸","ğŸª¸"},
         {"ğŸª¸","ğŸ ","âšª","  ","ğŸª¸","âšª","ğŸª¸"},
         {"ğŸª¸","  ","ğŸª¸","  ","âšª","  ","ğŸª¸"},
         {"ğŸª¸","âšª","  ","ğŸª¸","  ","ğŸ¦ˆ","ğŸª¸"},
         {"ğŸª¸","âšª","  ","âšª","ğŸª¸","  ","ğŸª¸"},
         {"ğŸª¸","ğŸ¦ˆ","  ","  ","  ","âšª","ğŸª¸"},
         {"ğŸª¸","ğŸª¸","ğŸª¸","ğŸª¸","ğŸª¸","ğŸª¸","ğŸª¸"}}
    }},

    {"forest", {
        {{"ğŸŒ²","ğŸŒ²","ğŸŒ²","ğŸŒ²","ğŸŒ²","ğŸŒ²","ğŸŒ²"},
         {"ğŸŒ²","ğŸ°","ğŸ„","  ","ğŸŒ²","ğŸ„","ğŸŒ²"},
         {"ğŸŒ²","  ","ğŸŒ²","  ","ğŸ„","  ","ğŸŒ²"},
         {"ğŸŒ²","ğŸ„","ğŸŒ²","ğŸ„","  ","ğŸº","ğŸŒ²"},
         {"ğŸŒ²","  ","ğŸŒ²","  ","ğŸŒ²","  ","ğŸŒ²"},
         {"ğŸŒ²","ğŸ„","  ","ğŸ„","  ","ğŸ„","ğŸŒ²"},
         {"ğŸŒ²","ğŸŒ²","ğŸŒ²","ğŸŒ²","ğŸŒ²","ğŸŒ²","ğŸŒ²"}}
    }},

    {"city", {
        {{"ğŸš§","ğŸš§","ğŸš§","ğŸš§","ğŸš§","ğŸš§","ğŸš§"},
         {"ğŸš§","ğŸš—","âšª","  ","ğŸš§","âšª","ğŸš§"},
         {"ğŸš§","  ","ğŸš§","  ","âšª","  ","ğŸš§"},
         {"ğŸš§","âšª","ğŸš§","âšª","ğŸš§","ğŸ‘®","ğŸš§"},
         {"ğŸš§","  ","  ","  ","âšª","  ","ğŸš§"},
         {"ğŸš§","âšª","  ","âšª","  ","âšª","ğŸš§"},
         {"ğŸš§","ğŸš§","ğŸš§","ğŸš§","ğŸš§","ğŸš§","ğŸš§"}}
    }},

    {"space", {
        {{"ğŸŒ‘","ğŸŒ‘","ğŸŒ‘","ğŸŒ‘","ğŸŒ‘","ğŸŒ‘","ğŸŒ‘"},
         {"ğŸŒ‘","ğŸš€","âœ¨","  ","ğŸŒ‘","âœ¨","ğŸŒ‘"},
         {"ğŸŒ‘","  ","ğŸŒ‘","  ","âœ¨","  ","ğŸŒ‘"},
         {"ğŸŒ‘","âœ¨","ğŸŒ‘","âœ¨","ğŸŒ‘","ğŸ‘¾","ğŸŒ‘"},
         {"ğŸŒ‘","  ","  ","  ","âœ¨","  ","ğŸŒ‘"},
         {"ğŸŒ‘","âœ¨","  ","âœ¨","  ","âœ¨","ğŸŒ‘"},
         {"ğŸŒ‘","ğŸŒ‘","ğŸŒ‘","ğŸŒ‘","ğŸŒ‘","ğŸŒ‘","ğŸŒ‘"}}
    }}
};

temka now_temka = sea;


// Ñ‚ÑƒÑ‚ Ğ½Ğ°ÑÑ‚Ñ€Ğ¾Ğ¹ĞºĞ° ÑƒÑ€Ğ¾Ğ²Ğ½Ñ Ğ±ÑƒĞ´ĞµÑ‚ Ñ€Ğ°Ğ·Ğ¼ĞµÑ€Ñ‹

// Ğ²Ğ°ÑˆĞ° Ñ‡Ğ°ÑÑ‚ÑŒ Ğ³ĞµÑ€Ğ»Ğ·

//ÑĞ°Ñˆ, Ğ¿Ñ€Ğ¾Ğ²ĞµÑ€ÑŒ Ğ¿Ğ¶ Ğ½Ğ° Ñ‡Ñ‚Ğ¾ Ğ°Ğ³Ñ€Ğ¸Ñ‚ÑÑ ._.
void setupLevel(int levelNum, const string& themeName) {
    now = sort_theme[themeName][levelNum];
    HEIGHT = now.size();
    WIDTH = now[0].size();
    monsters.clear();
    for (int y = 0; y < HEIGHT; y++) {
        for (int x = 0; x < WIDTH; x++) {
            string &cell = now[y][x];
            if (cell == "ğŸ " || cell == "ğŸ°" || cell == "ğŸš—" || cell == "ğŸš€") {
                player = {x, y};
                cell = now_t.player;
            } else if (cell == "ğŸ¦ˆ" || cell == "ğŸº" || cell == "ğŸ‘®" || cell == "ğŸ‘¾") {
                monsters.push_back({x, y});
                cell = now_t.monster;
            } else if (cell == "ğŸª¸" || cell == "ğŸŒ²" || cell == "ğŸš§" || cell == "ğŸŒ‘") {
                cell = now_t.wall;
            } else if (cell == "âšª" || cell == "ğŸ„" || cell == "ğŸ›" || cell == "âœ¨") {
                cell = now_t.point;
            } else if (cell == "â­" || cell == "ğŸ¥•" || cell == "ğŸ’" || cell == "ğŸŒŸ") {
                cell = now_t.BONUS;
            } else {
                cell = now_t.empty;
            }
        }
    }
}
bool checkWin() {
    for (auto &row : now)
        for (auto &cell : row)
            if (cell == now_t.point || cell == now_t.BONUS)
                return false;
    return true;
}
bool checkCollision(int x, int y) {
    return (now[y][x] == now_t.wall ||
            now[y][x] == now_t.monster);
}
void moveMonsters() {
    for (auto &m : monsters) {
        int nx = m.x, ny = m.y;
        int dir = rand() % 4;
        if (dir == 0) ny--;
        else if (dir == 1) ny++;
        else if (dir == 2) nx--;
        else if (dir == 3) nx++;
        if (nx >= 0 && ny >= 0 && nx < WIDTH && ny < HEIGHT && now[ny][nx] == now_t.empty) {
            now[m.y][m.x] = now_t.empty;
            m.x = nx; m.y = ny;
            now[m.y][m.x] = now_t.monster;
        }
    }
}
//Ğ° Ğ½Ğ¸Ñ‡Ğ¾ Ñ‚Ğ¾Ñ‚ Ñ„Ğ°ĞºÑ‚ Ñ‡Ñ‚Ğ¾ Ñƒ Ğ½Ğ°Ñ Ğ´ĞµĞ´Ğ»Ğ°Ğ¹Ğ½ ÑĞµĞ³Ğ¾Ğ´Ğ½Ñ Ğ´Ñ€ÑƒĞ·ÑŒÑ, Ğ½Ğµ Ğ¸Ğ³Ğ½Ğ¾Ñ€ÑŒÑ‚Ğµ Ğ² Ñ‚ĞµĞ»ĞµĞ³Ğµ ÑƒĞ¼Ğ¾Ğ»ÑÑ

void renderLevel(SDL_Renderer* renderer, TTF_Font* font) //Ğ¾ĞºĞ¾ÑˆĞºĞ¾
{
    SDL_SetRenderDrawColor(renderer, 0, 0, 0, 255);
    SDL_RenderClear(renderer);
    SDL_Color textColor = {255, 255, 255, 255};



//ÑĞµÑ‚ĞºĞ° 
for (int y = 0; y < HEIGHT; y++) {
        for (int x = 0; x < WIDTH; x++) {
            std::string cellText = now[y][x];

            SDL_Surface* surface = TTF_RenderText_Solid(font, cellText.c_str(), textColor);
            if (!surface) {
                std::cerr << "ĞÑˆĞ¸Ğ±ĞºĞ° TTF_RenderText_Solid: " << SDL_GetError() << std::endl;
                continue;
            }

            SDL_Texture* texture = SDL_CreateTextureFromSurface(renderer, surface);
            int texW = surface->w;
            int texH = surface->h;
            SDL_DestroySurface(surface);

            if (!texture) {
                std::cerr << "ĞÑˆĞ¸Ğ±ĞºĞ° SDL_CreateTextureFromSurface: " << SDL_GetError() << std::endl;
                continue;
            }

            SDL_FRect destRect = { static_cast<float>(x * CELL_SIZE), static_cast<float>(y * CELL_SIZE), static_cast<float>(CELL_SIZE), static_cast<float>(CELL_SIZE) };

            // Ğ¦ĞµĞ½Ñ‚Ñ€Ğ¸Ñ€ÑƒĞµĞ¼ Ñ‚ĞµĞºÑÑ‚ Ğ² ÑÑ‡ĞµĞ¹ĞºĞµ
            int offsetX = (CELL_SIZE - texW) / 2;
            int offsetY = (CELL_SIZE - texH) / 2;
            destRect.x += offsetX;
            destRect.y += offsetY;

            SDL_RenderTexture(renderer, texture, NULL, &destRect);
            SDL_DestroyTexture(texture); 
        }
    }

//Ğ¸Ğ½Ñ„Ğ° Ğ¾Ğ± ÑƒÑ€Ğ¾Ğ²Ğ½Ğµ
std::string attemptsText = "ĞŸĞ¾Ğ¿Ñ‹Ñ‚ĞºĞ°: " + std::to_string(attempts);
    SDL_Surface* surface = TTF_RenderText_Solid(font, attemptsText.c_str(), textColor);
    if (surface) {
        int textW = surface->w;
        int textH = surface->h;
        SDL_Texture* texture = SDL_CreateTextureFromSurface(renderer, surface);
        SDL_DestroySurface(surface);

        if (texture) {
            SDL_FRect destRect = { 10.0f, static_cast<float>(HEIGHT * CELL_SIZE + 10), static_cast<float>(textW), static_cast<float>(textH) };
            SDL_RenderTexture(renderer, texture, NULL, &destRect);
            SDL_DestroyTexture(texture);
        }
    }

    SDL_RenderPresent(renderer);
}
// Ñ‚ÑƒÑ‚ Ğ²Ğ°Ñˆ Ğ¾ÑĞ½Ğ¾Ğ²Ğ½Ğ¾Ğ¹ Ñ†Ğ¸ĞºĞ»
// Ğ¼Ğ°Ñˆ Ğ¿Ğ¸ÑˆĞ¸ Ñ‡ĞµÑ€ĞµĞ· using Ğ¿Ğ¶, Ñ‚Ğ°Ğº Ğ°ĞºĞºÑƒÑ€Ğ°Ñ‚Ğ½ĞµĞµ ÑĞ¼Ğ¾Ñ‚Ñ€Ğ¸Ñ‚ÑÑ :)

