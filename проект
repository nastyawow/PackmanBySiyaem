#include <SDL3/SDL.h>
#include <SDL3_ttf/SDL_ttf.h>
#include <iostream>
#include <vector>
#include <string>
#include <unordered_map>
#include <ctime>
#include <cstdlib>

using std::cin;
using std::cout;
using std::endl;
using std::vector;
using std::unordered_set;
using std::string;

struct Thema { //Ğ½Ğ°ÑˆĞ¸ Ñ‚ĞµĞ¼Ñ‹
    std::string PLAYER, MONSTER, WALL, POINT, EMPTY = "  ";
}

int WIDTH, HEIGHT; //Ğ½Ñƒ Ñ‚ÑƒÑ‚ Ğ¿Ğ¾Ğ½ÑÑ‚Ğ½Ğ¾
int attempts = 0;
bool gameover;

struct Entity { //ĞºĞ¾Ğ¾Ñ€Ğ´Ğ¸Ğ½Ğ°Ñ‚Ñ‹ ĞºĞ°ĞºĞ¾Ğ¹ Ñ‚Ğ¾ ÑÑƒÑ‰Ğ½Ğ¾ÑÑ‚Ğ¸
   int x, y;
}

Entity player;
std::vector<Entity> monsters



Thema SEA    = {"ğŸ ", "ğŸ¦ˆ", "ğŸª¸", "âšª", "â­"};   // ĞœĞ¾Ñ€ÑĞºĞ°Ñ
Thema FOREST = {"ğŸ°", "ğŸº", "ğŸŒ²", "ğŸ„", "ğŸ¥•"};   // Ğ›ĞµÑĞ½Ğ°Ñ
Thema CITY   = {"ğŸš—", "ğŸ‘®", "ğŸš§", "ğŸ›", "ğŸ’"};   // Ğ“Ğ¾Ñ€Ğ¾Ğ´ÑĞºĞ°Ñ
Thema SPACE  = {"ğŸš€", "ğŸ‘¾", "ğŸŒ‘", "âœ¨", "ğŸŒŸ"};   // ĞšĞ¾ÑĞ¼Ğ¸Ñ‡ĞµÑĞºĞ°Ñ

std::vector<Thema> thems = {SEA, FOREST};
Theme currentTheme = SEA;
std::vector<vector<string>> currentLevel;


std::unordered_map<string, vector<vector<vector<string>>>> LevelsByThems = {
    {"SEA", {
        {{"ğŸª¸","ğŸª¸","ğŸª¸","ğŸª¸","ğŸª¸","ğŸª¸","ğŸª¸"},
         {"ğŸª¸","ğŸ ","âšª","  ","ğŸª¸","âšª","ğŸª¸"},
         {"ğŸª¸","  ","ğŸª¸","  ","âšª","  ","ğŸª¸"},
         {"ğŸª¸","âšª","  ","ğŸª¸","  ","ğŸ¦ˆ","ğŸª¸"},
         {"ğŸª¸","âšª","  ","âšª","ğŸª¸","  ","ğŸª¸"},
         {"ğŸª¸","ğŸ¦ˆ","  ","  ","  ","âšª","ğŸª¸"},
         {"ğŸª¸","ğŸª¸","ğŸª¸","ğŸª¸","ğŸª¸","ğŸª¸","ğŸª¸"}}
    }},

    {"FOREST", {
        {{"ğŸŒ²","ğŸŒ²","ğŸŒ²","ğŸŒ²","ğŸŒ²","ğŸŒ²","ğŸŒ²"},
         {"ğŸŒ²","ğŸ°","ğŸ„","  ","ğŸŒ²","ğŸ„","ğŸŒ²"},
         {"ğŸŒ²","  ","ğŸŒ²","  ","ğŸ„","  ","ğŸŒ²"},
         {"ğŸŒ²","ğŸ„","ğŸŒ²","ğŸ„","  ","ğŸº","ğŸŒ²"},
         {"ğŸŒ²","  ","ğŸŒ²","  ","ğŸŒ²","  ","ğŸŒ²"},
         {"ğŸŒ²","ğŸ„","  ","ğŸ„","  ","ğŸ„","ğŸŒ²"},
         {"ğŸŒ²","ğŸŒ²","ğŸŒ²","ğŸŒ²","ğŸŒ²","ğŸŒ²","ğŸŒ²"}}
    }},

    {"CITY", {
        {{"ğŸš§","ğŸš§","ğŸš§","ğŸš§","ğŸš§","ğŸš§","ğŸš§"},
         {"ğŸš§","ğŸš—","âšª","  ","ğŸš§","âšª","ğŸš§"},
         {"ğŸš§","  ","ğŸš§","  ","âšª","  ","ğŸš§"},
         {"ğŸš§","âšª","ğŸš§","âšª","ğŸš§","ğŸ‘®","ğŸš§"},
         {"ğŸš§","  ","  ","  ","âšª","  ","ğŸš§"},
         {"ğŸš§","âšª","  ","âšª","  ","âšª","ğŸš§"},
         {"ğŸš§","ğŸš§","ğŸš§","ğŸš§","ğŸš§","ğŸš§","ğŸš§"}}
    }},

    {"SPACE", {
        {{"ğŸŒ‘","ğŸŒ‘","ğŸŒ‘","ğŸŒ‘","ğŸŒ‘","ğŸŒ‘","ğŸŒ‘"},
         {"ğŸŒ‘","ğŸš€","âœ¨","  ","ğŸŒ‘","âœ¨","ğŸŒ‘"},
         {"ğŸŒ‘","  ","ğŸŒ‘","  ","âœ¨","  ","ğŸŒ‘"},
         {"ğŸŒ‘","âœ¨","ğŸŒ‘","âœ¨","ğŸŒ‘","ğŸ‘¾","ğŸŒ‘"},
         {"ğŸŒ‘","  ","  ","  ","âœ¨","  ","ğŸŒ‘"},
         {"ğŸŒ‘","âœ¨","  ","âœ¨","  ","âœ¨","ğŸŒ‘"},
         {"ğŸŒ‘","ğŸŒ‘","ğŸŒ‘","ğŸŒ‘","ğŸŒ‘","ğŸŒ‘","ğŸŒ‘"}}
    }}
};

Thema currentThema = SEA;


// Ñ‚ÑƒÑ‚ Ğ½Ğ°ÑÑ‚Ñ€Ğ¾Ğ¹ĞºĞ° ÑƒÑ€Ğ¾Ğ²Ğ½Ñ Ğ±ÑƒĞ´ĞµÑ‚ Ñ€Ğ°Ğ·Ğ¼ĞµÑ€Ñ‹

// Ğ²Ğ°ÑˆĞ° Ñ‡Ğ°ÑÑ‚ÑŒ Ğ³ĞµÑ€Ğ»Ğ·

void renderLevel(SDL_Renderer* renderer, TTF_Font* font) //Ğ¾ĞºĞ¾ÑˆĞºĞ¾
{
    SDL_SetRenderDrawColor(renderer, 0, 0, 0, 255);
    SDL_RenderClear(renderer);

    SDL_Color textColor = {255, 255, 255, 255};



//ÑĞµÑ‚ĞºĞ° 
for (int y = 0; y < HEIGHT; y++) {
        for (int x = 0; x < WIDTH; x++) {
            std::string cellText = currentLevel[y][x];

            SDL_Surface* surface = TTF_RenderText_Solid(font, cellText.c_str(), textColor);
            if (!surface) {
                std::cerr << "ĞÑˆĞ¸Ğ±ĞºĞ° TTF_RenderText_Solid: " << SDL_GetError() << std::endl;
                continue;
            }

            SDL_Texture* texture = SDL_CreateTextureFromSurface(renderer, surface);
            int texW = surface->w;
            int texH = surface->h;
            SDL_DestroySurface(surface);

            if (!texture) {
                std::cerr << "ĞÑˆĞ¸Ğ±ĞºĞ° SDL_CreateTextureFromSurface: " << SDL_GetError() << std::endl;
                continue;
            }

            SDL_FRect destRect = { static_cast<float>(x * CELL_SIZE), static_cast<float>(y * CELL_SIZE), static_cast<float>(CELL_SIZE), static_cast<float>(CELL_SIZE) };

            // Ğ¦ĞµĞ½Ñ‚Ñ€Ğ¸Ñ€ÑƒĞµĞ¼ Ñ‚ĞµĞºÑÑ‚ Ğ² ÑÑ‡ĞµĞ¹ĞºĞµ
            int offsetX = (CELL_SIZE - texW) / 2;
            int offsetY = (CELL_SIZE - texH) / 2;
            destRect.x += offsetX;
            destRect.y += offsetY;

            SDL_RenderTexture(renderer, texture, NULL, &destRect);
            SDL_DestroyTexture(texture); 
        }
    }

//Ğ¸Ğ½Ñ„Ğ° Ğ¾Ğ± ÑƒÑ€Ğ¾Ğ²Ğ½Ğµ
std::string attemptsText = "ĞŸĞ¾Ğ¿Ñ‹Ñ‚ĞºĞ°: " + std::to_string(attempts);
    SDL_Surface* surface = TTF_RenderText_Solid(font, attemptsText.c_str(), textColor);
    if (surface) {
        int textW = surface->w;
        int textH = surface->h;
        SDL_Texture* texture = SDL_CreateTextureFromSurface(renderer, surface);
        SDL_DestroySurface(surface);

        if (texture) {
            SDL_FRect destRect = { 10.0f, static_cast<float>(HEIGHT * CELL_SIZE + 10), static_cast<float>(textW), static_cast<float>(textH) };
            SDL_RenderTexture(renderer, texture, NULL, &destRect);
            SDL_DestroyTexture(texture);
        }
    }

    SDL_RenderPresent(renderer);
}
// Ñ‚ÑƒÑ‚ Ğ²Ğ°Ñˆ Ğ¾ÑĞ½Ğ¾Ğ²Ğ½Ğ¾Ğ¹ Ñ†Ğ¸ĞºĞ»
// Ğ¼Ğ°Ñˆ Ğ¿Ğ¸ÑˆĞ¸ Ñ‡ĞµÑ€ĞµĞ· using Ğ¿Ğ¶, Ñ‚Ğ°Ğº Ğ°ĞºĞºÑƒÑ€Ğ°Ñ‚Ğ½ĞµĞµ ÑĞ¼Ğ¾Ñ‚Ñ€Ğ¸Ñ‚ÑÑ :)
