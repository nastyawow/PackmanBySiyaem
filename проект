#include <SDL3/SDL.h>
#include <SDL3_ttf/SDL_ttf.h>
#include <iostream>
#include <vector>
#include <string>
#include <unordered_map>
#include <ctime>
#include <cstdlib>

using std::cin;
using std::cout;
using std::endl;
using std::vector;
using std::unordered_set;
using std::string;

struct Thema { //наши темы
    std::string PLAYER, MONSTER, WALL, POINT, EMPTY = "  ";
}

int WIDTH, HEIGHT; //ну тут понятно
int attempts = 0;
bool gameover;

struct Entity { //координаты какой то сущности
   int x, y;
}

Entity player;
std::vector<Entity> monsters



Thema SEA    = {"🐠", "🦈", "🪸", "⚪", "⭐"};   // Морская
Thema FOREST = {"🐰", "🐺", "🌲", "🍄", "🥕"};   // Лесная
Thema CITY   = {"🚗", "👮", "🚧", "🛞", "💎"};   // Городская
Thema SPACE  = {"🚀", "👾", "🌑", "✨", "🌟"};   // Космическая

std::vector<Thema> thems = {SEA, FOREST};
Theme currentTheme = SEA;
std::vector<vector<string>> currentLevel;


std::unordered_map<string, vector<vector<vector<string>>>> LevelsByThems = {
    {"SEA", {
        {{"🪸","🪸","🪸","🪸","🪸","🪸","🪸"},
         {"🪸","🐠","⚪","  ","🪸","⚪","🪸"},
         {"🪸","  ","🪸","  ","⚪","  ","🪸"},
         {"🪸","⚪","  ","🪸","  ","🦈","🪸"},
         {"🪸","⚪","  ","⚪","🪸","  ","🪸"},
         {"🪸","🦈","  ","  ","  ","⚪","🪸"},
         {"🪸","🪸","🪸","🪸","🪸","🪸","🪸"}}
    }},

    {"FOREST", {
        {{"🌲","🌲","🌲","🌲","🌲","🌲","🌲"},
         {"🌲","🐰","🍄","  ","🌲","🍄","🌲"},
         {"🌲","  ","🌲","  ","🍄","  ","🌲"},
         {"🌲","🍄","🌲","🍄","  ","🐺","🌲"},
         {"🌲","  ","🌲","  ","🌲","  ","🌲"},
         {"🌲","🍄","  ","🍄","  ","🍄","🌲"},
         {"🌲","🌲","🌲","🌲","🌲","🌲","🌲"}}
    }},

    {"CITY", {
        {{"🚧","🚧","🚧","🚧","🚧","🚧","🚧"},
         {"🚧","🚗","⚪","  ","🚧","⚪","🚧"},
         {"🚧","  ","🚧","  ","⚪","  ","🚧"},
         {"🚧","⚪","🚧","⚪","🚧","👮","🚧"},
         {"🚧","  ","  ","  ","⚪","  ","🚧"},
         {"🚧","⚪","  ","⚪","  ","⚪","🚧"},
         {"🚧","🚧","🚧","🚧","🚧","🚧","🚧"}}
    }},

    {"SPACE", {
        {{"🌑","🌑","🌑","🌑","🌑","🌑","🌑"},
         {"🌑","🚀","✨","  ","🌑","✨","🌑"},
         {"🌑","  ","🌑","  ","✨","  ","🌑"},
         {"🌑","✨","🌑","✨","🌑","👾","🌑"},
         {"🌑","  ","  ","  ","✨","  ","🌑"},
         {"🌑","✨","  ","✨","  ","✨","🌑"},
         {"🌑","🌑","🌑","🌑","🌑","🌑","🌑"}}
    }}
};

Thema currentThema = SEA;


// тут настройка уровня будет размеры

// ваша часть герлз

//саш, проверь пж на что агрится ._.
void setupLevel(int levelNum, const std::string& themeName) {
    currentLevel = LevelsByTheme[themeName][levelNum];
    HEIGHT = currentLevel.size();
    WIDTH = currentLevel[0].size();
    monsters.clear();
    for (int y = 0; y < HEIGHT; y++) {
        for (int x = 0; x < WIDTH; x++) {
            std::string &cell = currentLevel[y][x];
            if (cell == "🐠" || cell == "🐰" || cell == "🚗" || cell == "🚀") {
                player = {x, y};
                cell = currentTheme.PLAYER;
            } else if (cell == "🦈" || cell == "🐺" || cell == "👮" || cell == "👾") {
                monsters.push_back({x, y});
                cell = currentTheme.MONSTER;
            } else if (cell == "🪸" || cell == "🌲" || cell == "🚧" || cell == "🌑") {
                cell = currentTheme.WALL;
            } else if (cell == "⚪" || cell == "🍄" || cell == "🛞" || cell == "✨") {
                cell = currentTheme.POINT;
            } else if (cell == "⭐" || cell == "🥕" || cell == "💎" || cell == "🌟") {
                cell = currentTheme.BONUS;
            } else {
                cell = currentTheme.EMPTY;
            }
        }
    }
}

bool checkWin() {
    for (auto &row : currentLevel)
        for (auto &cell : row)
            if (cell == currentTheme.POINT || cell == currentTheme.BONUS)
                return false;
    return true;
}
bool checkCollision(int x, int y) {
    return (currentLevel[y][x] == currentTheme.WALL ||
            currentLevel[y][x] == currentTheme.MONSTER);
}
void moveMonsters() {
    for (auto &m : monsters) {
        int nx = m.x, ny = m.y;
        int dir = rand() % 4;
        if (dir == 0) ny--;
        else if (dir == 1) ny++;
        else if (dir == 2) nx--;
        else if (dir == 3) nx++;
        if (nx >= 0 && ny >= 0 && nx < WIDTH && ny < HEIGHT &&
            currentLevel[ny][nx] == currentTheme.EMPTY) {
            currentLevel[m.y][m.x] = currentTheme.EMPTY;
            m.x = nx; m.y = ny;
            currentLevel[m.y][m.x] = currentTheme.MONSTER;
        }
    }
}


void renderLevel(SDL_Renderer* renderer, TTF_Font* font) //окошко
{
    SDL_SetRenderDrawColor(renderer, 0, 0, 0, 255);
    SDL_RenderClear(renderer);
    SDL_Color textColor = {255, 255, 255, 255};



//сетка 
for (int y = 0; y < HEIGHT; y++) {
        for (int x = 0; x < WIDTH; x++) {
            std::string cellText = currentLevel[y][x];

            SDL_Surface* surface = TTF_RenderText_Solid(font, cellText.c_str(), textColor);
            if (!surface) {
                std::cerr << "Ошибка TTF_RenderText_Solid: " << SDL_GetError() << std::endl;
                continue;
            }

            SDL_Texture* texture = SDL_CreateTextureFromSurface(renderer, surface);
            int texW = surface->w;
            int texH = surface->h;
            SDL_DestroySurface(surface);

            if (!texture) {
                std::cerr << "Ошибка SDL_CreateTextureFromSurface: " << SDL_GetError() << std::endl;
                continue;
            }

            SDL_FRect destRect = { static_cast<float>(x * CELL_SIZE), static_cast<float>(y * CELL_SIZE), static_cast<float>(CELL_SIZE), static_cast<float>(CELL_SIZE) };

            // Центрируем текст в ячейке
            int offsetX = (CELL_SIZE - texW) / 2;
            int offsetY = (CELL_SIZE - texH) / 2;
            destRect.x += offsetX;
            destRect.y += offsetY;

            SDL_RenderTexture(renderer, texture, NULL, &destRect);
            SDL_DestroyTexture(texture); 
        }
    }

//инфа об уровне
std::string attemptsText = "Попытка: " + std::to_string(attempts);
    SDL_Surface* surface = TTF_RenderText_Solid(font, attemptsText.c_str(), textColor);
    if (surface) {
        int textW = surface->w;
        int textH = surface->h;
        SDL_Texture* texture = SDL_CreateTextureFromSurface(renderer, surface);
        SDL_DestroySurface(surface);

        if (texture) {
            SDL_FRect destRect = { 10.0f, static_cast<float>(HEIGHT * CELL_SIZE + 10), static_cast<float>(textW), static_cast<float>(textH) };
            SDL_RenderTexture(renderer, texture, NULL, &destRect);
            SDL_DestroyTexture(texture);
        }
    }

    SDL_RenderPresent(renderer);
}
// тут ваш основной цикл
// маш пиши через using пж, так аккуратнее смотрится :)
